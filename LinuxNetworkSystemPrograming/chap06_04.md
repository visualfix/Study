## 6-4 I/O - 소켓 레이어와 IP 레이어 전송 시나리오

### 6-4.1 송신
- 소켓 레이어
	- 소켓에는 송/수신 버퍼가 있다. (각각 따로 존재)
		- 응용 프로그램에서 send, sendto, write 등의 쓰기 요청에 양수의 리턴값이 나오는 경우에는 소켓의 송신 버퍼로 데이터가 복사 됐음을 의미
		- TCP의 경우 복사된 데이터를 MTU에 맞게 미리 세그먼테이션함
			- 이때 기준이 되는 크기가 MSS(Maximum Segment Size)
			- MSS는 MTU보다는 작으므로  IP에서 다시 프래그멘테이션 되지 않음
		- UDP의 경우 세그먼테이션 없이 IP로 내려감
- IP레이어
	- 데이터의 크기가 MTU보다 큰 경우 프래그멘테이션한다.
- DataLink 레이어
	- MTU를 한번더 체크하고 패킷으로 포장해 전송한다.
### 6-4.2 수신
- IP 레이어
	- 프래그멘테이션을 확인하고 필요하면 재조합 한다.
	- TCP의 세그먼트 순서는 MSS로 잘린 순서일 뿐이므로 응용프로그램에서 조합해야한다.
	- UDP의 경우에는 수신 버퍼에서 송신처에서 보낸 형태 그대로 경계를 보존해 읽을 수 있도록 해준다.
	- 만일 DataGram이 MTU보다 큰 경우 였다면 수신처에서는 재조합을 거쳐 완전한 데이터그램이 되어야 읽을 수 있다.  

### 6-4.3 UDP 오버플로우  
- UDP를 사용할 때는 소켓 버퍼의 크기가 전송하는 데이터그램의 크기보다 크거나 같아야 한다.
- 수신 버퍼의 크기가 유저 데이터그램 보다 작은 경우에는 항상 실패하지만 송신버퍼가 작은 경우에는 전송이 성공할 수도 있다.
	- OS 구현에 따라 다른데 리눅스의 경우 송신버퍼가 작으면 프래그멘테이션 하며 전송한다.
- UDP 소켓의 수신버퍼가 오버플로되면 패킷을 버리는데 버려진 패킷은 netstat -s로 확인할 수 있다.
	- 만일 UDP유실이 심한 경우에는 버려진 패킷을 체크해보고 포트를 분산시키면 되지만
	- UDP의 최대 크기를 줄이는 것이 더 좋다.

### 6-4.4 TCP의 효율적 기법들

- Nagle Algorithm
	- 네트워크 상에서 너무 작은 패킷들이 빈번하게 이동하면 데이터그램보다 헤더의 사이즈가 더 커져 오버헤드가 발생한다.
	- 이 문제를 해결하기 위해 작은 패킷을 모아두었다가 ACK가 수신되었을 때 전송하는 것을 nagle 알고리즘이 라고 한다.
	- ACK 수신이 빠르면 그만큼 빨리 송신하고 너무 늦더라도 타임아웃 시간 후에는 ACK를 받을 수 있다.   
	(200ms 정도 :  지연 ACK와 관련)
- 지연 ACK
	- 수신측에서 송신측에 보내야하는 데이터가 있을 때 ACK 번호를 함께 실어 보내는 방법
	- 일반적으로 수신만 하는 경우에는 위와 같은 방법을 사용할 수 없어 아래 경우에 ACK를 보낸다
      	1. 타임아웃이 되면 ACK 보냄 : 500ms를 권고 하지만 보통 200ms를 사용함
      	2. 수신측이 recv같은 읽기 요청으로 버퍼가 비워지는 경우  
		보통 슬라이딩 윈도우의 절반, MSS크기의 두배 이상 크기 데이터를 읽었을 때
- 슬라이딩 윈도우
	- 수신측은 송신측에 윈도우 크기를 알려주는데 이는 수신측의 버퍼링 수준을 의미함
	- 송신측은 응답이 없어도 윈도우가 받을 수 있다면 패킷을 전송함  
송신측은 알고 있는 윈도우 크기를 줄이며 데이터를 전송하고 수신측은 일정 시간바다 ACK에 윈도우 크기를 담아 전송한다.
	- 전송과정에서 오류가 발생하거나 수신측에서 데이터를 느리게 읽는 경우 윈도우 크기를 줄여 응답해 속도 조절을 한다.
- TCP Autotuning
	- 리눅스에서 TCP버퍼 크기를 전송량에 따라 자동으로 조정하는 기능

### 6-4.5 소켓 옵션

- SO_REUSERADDR
	- TCP : TIME_WAIT 상태에 빠진 주소:포트 를 강제로 bind해 사용할 수 있도록 해준다.
	- UDP : 복수개의 프로세스가 같은 포트를 bind할 수 있도록 해준다.  
	하지만 실제로는 마지막에 사용된 UDP 프로세스가 포트를 bind하고 점유한다.
- SO_RCVBUF, SO_SNDBUF
	- 리눅스에서는 리눅스에서 사용하는 부가 정보 때문에 버퍼사이즈가 2배로 표시된다.
	- 몇몇 유닉스에서는 버퍼 사이즈를 변경 할 수 없다.
	- 버퍼 사이즈가 크면 속도나 안정성에서 이점이 있지만 소켓의 생성/파괴가 빈번한 경우 메모리 할당에 오버헤드가 생길 수 있다.
	- 소켓버퍼가 메모리에 과하게 할당되면 (일반적으로 시스템의 85% 이하) 새로운 소켓 할당이 거부되고 TCP autotuning 같은 기능으로 메모리를 확보한다.
	- TCP의 경우에는 소켓 버퍼에 세그먼트들이 저장되기 때문에 전송속도를 증가 시키기 위해 버퍼 사이즈를 늘리는 경우가 많다.
		- 하지만 TCP의 경우 송/수신 버퍼가 완충제 역할을 하는 것이 기때문에 작아도 큰 문제가 발생하지는 않는다.
		- 송신측 Recv가 느려져 윈도우 사이즈가 0이 되고 송신측 버퍼까지 포화되는 문제가 발생하면 버퍼를 늘려도 포화까지의 시간만 늘어날 뿐이다.  
		근본적인 문제 데이터를 읽는 로직을 수정해 근본적인 문제를 해결해야한다.
		- TCP 버퍼 사이즈가 아예 의미가 없는 것은 아니지만 최신 OS는 버퍼 사이즈를 자동으로 조절해주기 때문에 큰 의미가 없다.
	- UDP의 경우 UDP 수신버퍼가 단편화된 조각들을 모아 데이터 그램을 완성해주는 곳이므로 완성된 데이터 그램이 들어갈 만큼 충분한 크기를 가져야한다.
- SO_LINGER
	- TCP에서만 사용되며 송신 버퍼의 데이터가 완전히 전송되었는지 확인할 때 사용하거나 연결을 강제로 취소해 TIME_WAIT 상태를 만들지 않는 용도로 사용한다.
	- 데이터 전송의 완료를 체크할 때 shutdown 함수의 half-close 나 l_linger 타임아웃을 사용하는 것은 불완전 하며 app에서 응답 메시지를 주고 받아 체크해야한다.
- SO_KEEPALIVE
	- 일정 시간마다 TCP연결 상태를 검사한다.
	- 통신 구간의 라우터에 문제가 발생했거나 호스트의 전원이 갑자기 나갔을 경우를 체크
	- TCP접속 후 너무 오랜 시간동안 전송이 없으면 L4, L7 스위치의 방화벽이 연결에 문제가 있다고 판단하고 삭제하는 경우가 있음
- TCP_NODELAY
	- Nagle 알고리즘 ON/OFF
- TCP_CORK
	- 작은 데이터를 모아두었다가 전송하는 기능 - 대용량 전송에 유리함

