##4 메모리
###4.1 프로세스의 메모리
#### 4.1.1 objdump, readelf를 사용해 확인할 수 있다
“objdump -x 실행파일"

- 텍스트(text)
>- 프로그램의 실행코드가 존재하는 영역 (컴파일 후 만들어진 기계어)
- 데이터(data)
>- 전역 변수, 정적 심볼들이 존재하는 영역
>>- rodata : 읽기 전용으로 초기화 되는 영역
const, format string, 상수 문자열
>>- data : 읽기/쓰기가 가능한 영역으로 초기화되는 영역
전역 변수 중 초기화 값이 있는 것들
>>- BSS : 초기화 되지 않는 영역
전역, static 변수 중 초기화 되지 않은 것들
- 스택(stack)
>- 함수의 시작에서 자동으로 생성되고 파괴되는 변수
>- 스택은 할당만 하고 해제하지 않는다
>>- 지정된 stack size를 넘어가면 오류발생
>- VLA배열
>>- C99표준
>>- 힙을 사용하지 않고 가변으로 배열을 사용할 수 있도록함
속도가 빠르고 메모리 누수를 생각하지 않아도 되기 때문에 많이 사용됨
>>- struct, union의 멤버, 전역 변수로는 선언될 수 없다
함수 스코프 안에서만 사용할 수 있음
- 힙(heap)
>- 메모리 할당 함수를 사용하여 얻는 공간
>- 프로세스가 종료되기 전에는 자동으로 파괴되지 않음

#### 4.1.2 메모리 락(memory lock)
페이징을 사용하면 보안 관련 데이터가 하드 디스크에 남을 수 있고 고성능을 요구하는 시스템의 경우 성능 이슈가 발생 할 수 있다
이를 방지하기 위해 메모리 락을 사용한다
메모리 락 설정, 해제 시 중복 호출 해도 여러번 락이 걸리거나 해제되지는 않는다

- mlock
>- 주소 위치부터 len만큼 메모리 락
>- 페이지 경계에서 시작하게 하지 않으면 오류가 발생 할 수 있음
- mlockall
>- 프로세스의 모든 메모리 락
- munlock, munlockall
>- 메모리 락 해제
     