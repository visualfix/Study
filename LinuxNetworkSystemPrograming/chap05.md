## 5 IPC
### 5.1 MMAP
#### 5.1.1 개요
파일을 메모리와 1:1 대응 시키는 기법
하드웨어나 블록 장치에 접근할 때 복잡한 단계를 거치지 않고 메모리 맵과 사상된 주소에 직접 쓰고 읽음
불필요한 메모리 페이징을 막고 시스템 호출을 사용하지 않게 되어 성능 향상
다수의 프로세스가 mmap을 만들면 실제 메모리 공간이 한개만 만들어지기 때문에 성능/효율 향상

- 운영체제는 메모리가 부족해지면 page out을 실행하는데 읽기 전용으로 열리 파일은 
이미 디스크에 파일이 있기 때문에 page out을 수행하지 않음
>- 실행 파일이나 동적 라이브러리의 로딩은 page out을 수행하지 않음
>- 동일한 파일을 여러 프로세스에서 로드할 때 mmap을 사용하게 하면 명확한 성능 향상을 꾀할 수 있음
- 파일 포인터가 메모리 주소값에 매핑되므로 lseek 함수를 사용하지 않고도 바로 주소 번지로 이동할 수 있음
- 읽기 전용이 아닌 쓰기 기능을 함께 사용하는 경우 이점이 많이 희석되지만 일반적인 파일 쓰기 방식보다 빠르고 일관성을 유지 할 수있는 이점이 있다
>- mmap을 통한 쓰기는 시스템 호출로 인식되지 않고 커널이 자동으로 동기화를 수행함
>- 여러 프로세스에서 공유할 수 있음 (lock 사용 필수)

#### 5.1.2 공유(shared), 사설(private) mode
공유 방식은 대응된 파일과 메모리가 지속적으로 동기화됨

- 한개의 프로세스가 mmap을 변경하면 다른 프로세스에서도 내용이 변경됨
- 항상 원본이 존재하기 때문에 page out이 발생하지 않음

사설 방식은 처음 생성시에만 파일 내용을 복사하고 끊어짐

- mmap이 생성된 후에 내용이 변경되면 프로세스의 고유 메모리 공간으로 전환되며 page out이 될 수 있음
- mlock을 통해 paging을 막거나 메모리 조언(posix_madvise)를 통해 효율적으로 동작하게 할 수 있음

기본적으로 mmap은 thread-safty

- 하지만 공유된 mmap이 최종적으로 쓰여진 데이터는 아닐 수 있기 때문에 msync를 통해 동기화를 마치고 사용해야함

munmap으로 해제

- 다른 프로세스에서 사용중 일 경우 해제 하지 않음
- 공유 방식일 경우 msync를 통해 동기화를 마치고 해제 

#### 5.1.3 함수 원형
` void * mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);`

- start

>- 0을 넣으면 자동으로 메모리 주소를 할당 해줌
>- 고정된 주소를 사용하려면 flags에 MAP_FIXED를 세팅하고 start에는 페이지 크기의 경계를 입력

- length

>- mmap을 생성할 메모리 크기로서 대응 할 파일보다 작아야함

- prot

>- 메모리 보호 권한을 설정
>- 파일 기술자의 권한게 동일하게 설정하지 않으면 오류 발생

- flags

>- 공유, 사설, 고정 주소 사용을 세팅 할 수 있음
>- 리눅스에서 확장된 기능들이 있으나 리눅스 버전마다 다를 수 있으니 사용전에 메뉴얼 페이지를 참고

`int munmap(void *start, size_t length);`

- 현재 프로세스와 mmap의 연결을 끊는다
- mmap 세그먼트를 해제하는 것은 아니며 모든 프로세스에서 mmap을 사용하지 않을 때만 해제된다

#### 5.1.4 메모리 사용패던 조언
- 메모리를 어떻게 다룰 것인지 힌트를 제공
- `int posix_madvise(void *addr, size_t len, int advise);`
>- addr 부터 len 만큼의 메모리를 advise용도로 사용함
>- advise 옵션에는 순차접근, 랜덤접근, 곧 사용, 앞으로 사용하지 않음 의 옵션을 지정할 수 있다
- `int posix_fadvise(int fd, off_t offset, off_t len, int advise);`
>- mmap을 사용하지 않은 파일에 사용패턴 조언을 할 때 사용

### 5.2 XSI 공유 메모리

- shmget : 공유 메모리의 IPC ID를 얻는다. (없는 경우에는 생성 후 ID를 반환한다)
- shmat : 지정한 IPC ID에 해당하는 공유 메모리에 연결한다. 성공시 메모리 주소를 반환한다.
- shmdt : 공유 메모리와 연결을 해제한다.
- shmtl : 공유 메모리를 조작한다. (제거 / 메타 데이터 얻기)

- 다른 프로세스에서 사용중인 공유 메모리를 제거하면?

>- 리눅스
연결된 프로세스가 존재하는 경우 제거 예약만 하고 실제로는 제거하지 않는다.
모든 프로세스와 연결이 끊어지면 제거되고 ipcs로 확인했을 때 status에 dest라고 표시된다.

>- 유닉스
리눅스 처럼 제거 유예가 있을 수도 없을 수도 있다.
유닉스의 경우 제거에 대한 규약이 표준에 없기 때문에 각 유닉스 벤더에 따라 동작이 다를 수 있다.
연결 횟수가 0이 된 공유 메모리는 누군가 건드리지 않는 이상 계속 보존된다.
(시스템이 재부팅 되면 사라진다)

### 5.3 POSIX 공유 메모리
리눅스 리얼타임 라이브러리인 -lrt로 링크를 해주어야 한다.
shm_open : POSIX 공유 메모리의 기술자를 얻는다 (없는 경우 생성)
mmap : 공유 메모리 기술자를 메모리 맵으로 매핑한다
close : 공유 메모리 기술자를 닫는다
shm_unlink : POSIX 공유 메모리를 제거한다

### 5.4 세마포어
- 카운팅 세마포어
복수개의 자원 카운팅이 가능한 세마포어
>- P/V 오퍼레이션
네덜란드어인 probeer te verlangen(try to reduce)와 verhogen(increase)에서 따왔기 때문에 P, V를 사용한다.
최근에 P는 Wait V는 Signal 이라고 부르는 경우가 많아지고 있다.
>- P 오퍼레이션으로 진입하는 프로세스는 자원을 하나씩 가져가고 더 이상 남는 자원이 없는 경우에는 대기 큐로 삽입된다.
이후  프로세스가 자원을 반환하면서 V 오퍼레이션을 보내면 대기큐에 있는 프로세스를 꺼내며 자원 값을 감소시키고 로직에 진입한다.

- 이진 세마포어
1개의 자원 카운팅이 가능한 세마포어
- 뮤텍스
독점적인 획득을 가능하게 하는 특수한 형태의 락
- 스핀락
문맥 교환을 막기 위해 사용되는 매우 빠른 특수한 형태의 락
- R/WLock (Read/Write 락)
읽기, 쓰기가 서로 다르게 적용되는 특수한 형태의 락

#### 5.4.1 세마포어 VS 뮤텍스
- 일반적으로 뮤텍스는 세마포어 보다 빠르다.
뮤텍스의 카운터와 대기열에는 정교한 구현이 필요 없기 때문이며 최근에는 뮤텍스의 구현을 하드웨어 레벨에서 도와주기 때문에 더 많이 가벼워지고 있다.
- 세마포어는 P,V 오퍼레이션이 항상 일치하지 않아도 되기 때문에 환형큐나 그래프 노드별 동기화를 쉽게 구현할 수 있는 장점이 있다.
- 최근에는 추가된 Undo 기능을 이용하면 프로세스가 락을 걸고 종료되는 경우 이상 동작을 방지할 수 있다. (성능이 약간 하락함)

#### 5.4.2 XSI 세마포어 VS POSIX 세마포어
- POSIX 세마포어가 90년대에 표준화되었기 때문에 XSI 세마포어로 구현된 시스템이 더 많이 존재한다.
(XIS 세마포어가 더 많은 기능을 제공하기 때문이기도함) 
 - 2008년 이후로는 POSIX세마포어가 더 빨라짐
- POSIX 세마포어에는 명명된 세마포어/익명 세마포어가 있는데 프로세서간 공유를 사용하느냐, 사용하지 않느냐에 따라 구분된다.
명명된 세마포어는 이름만 알고 있으면 외부 프로세서에서도 쉽게 접근 할수 있으나
익명 세마포어는 프로세서간 공유를 위해서 공유 메모리를 사용해 세마포어 객체를 저장해야하기 때문에
프로세서간 공유가 필요한 경우에는 명명된 세마포어를 사용하는 것이 좋다.

### 5.5 메시지큐
- 1~2KiB 이하의 짧은 메시지를 주고받는데 매우 효율적인 통신 메커니즘이다.
메시지큐는 큐가 가득차면 메시지를 버리거나 다른곳에 저장하기 때문에 이보다 더 큰 메시지는 소켓을 이용하는것이 좋다.
- 메시지큐는 Thread-Safety를 만족하므로 추가적으로 lock메커니즘을 사용할 필요가 없다.

- XSI 메시지큐
메시지에 타입(long)을 지정해 수신측에서 메시지를 분류해 받도록 할 수 있다.
- POSIX 메시지 큐
메시지를 받았을 때 수행할 이벤트를 지정할 수 있다.