## 2 파일처리
### 2.1 저수준 및 고수준 파일처리
#### 2.1.1 저수준 파일처리
- 파일 기술자 (file descriptor)번호를 이용해 입출력하는 방식
ex. 소켓, 디바이스 헨들링
- 비 직관적
유닉스 또는 호환 계열에서만 사용가능
원자적 실행
#### 2.1.2 고수준 파일처리
- 직관적, 사용이 편리한 함수 형태
C언어를 지원하는 모든 플렛폼에서 사용가능
라이브러리 레벨의 버퍼링이 있음

### 2.2 저수준 파일 처리의 사용
#### 2.2.1 open
- O_EXCL 옵셥을 사용하면 동일한 파일이 존재할 때 예외 처리를 할 수 있음
- 파일 동기화
> - 수동으로 동기화
> fsync, fdatasync 를 호출해 동기화
> - 자동으로 동기화
> - 플래그를 사용해 자동으로 동기화 되게 함
> O_SYNC : 파일 내용과 메타 데이터를 모두 동기화
> O_DSYNC : 파일 내용만 동기화 (비교적 가벼움)
> O_RSYNC : 읽기 작업 전에 밀린 쓰기 작업을 모두 수행
                 캐시 효과를 볼 수 없어서 느려짐
                 
- close-on-exec (O_CLOEXEC)
> exec 계열의 함수로 인해 다른 프로세스 이미지로 교체되면 파일이 자동으로 닫힘

#### 2.2.2 파일닫기
- 자주 접근하는 파일인 경우 파일 열기/닫기의 오버헤드를 줄이기 위해 파일을 열어둔 상태로 사용하는게 좋다.
- 자주 접근하지 않는 파일인 경우 프로세스에서 사용가능한 최대 파일 수를 고려해 바로 닫아주는 것이 좋을 수 있다.
( 소켓이나 디바이스 접근 또한 FD로 취급되기 때문에 주의해야함)
ulimit -n 명령으로 확인할 수 있음

#### 2.2.3 파일 사용 패턴 조언
- 파일에 순차적으로 접근할 것인지, 랜덤으로 접근할 것인지, 한번만 쓰고 버릴 것인지 지정 할 수 있음
> - 순차적으로 접근 하는 경우 다음 데이터를 미리 프리페칭
> - 한번만 사용하는 경우 캐시에서 바로 제거

### 2.3 고수준 파일 처리의 사용
- 성능적인 측면을 생각하면 저수준 파일 처리가 좋다 (특히 AIO)
버퍼링 때문임
- 원자적 실행이 아니다
- 입출력 빈도가 낮은 경우에는 성능차이가 거의 없다
- 버퍼링
> - fflush, setvbuf를 통해 버퍼를 제어 할 수 있다
>>- fflush : 바로 버퍼를 비운다
>>- setvbuf : 언제 버퍼를 비울지 지정한다.
옵션 : 라인 입력시, 버퍼링 사용안함, 모든 것을 버퍼링함
>- fork, exec, posix_spwan 등의 함수를 사용하는 경우 버퍼가 깨질 위험이 크기 때문에 반드시 버퍼를 비우고 실행해야한다
>- 바이너리 데이터 입출력
>>- fwrite, fread 사용
Padding이 있는 경우 주의해야함
>- XDR
>>- 통신 데이터는 빅 엔디안을 사용한다
